{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Spline = void 0;\nvar math_1 = require(\"../systems/math\");\n/**\r\n * Represents a spline that can be used to continueously evaluate a function\r\n * between keys. The base implementation is kept generic, so the functionality\r\n * can easily be implemented for similar constructs, such as gradients.\r\n */\nvar Spline = /** @class */function () {\n  /**\r\n   * Creates a new spline instance, using the specified keys.\r\n   * Note that you have to pass at least one key.\r\n   */\n  function Spline() {\n    var keys = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      keys[_i] = arguments[_i];\n    }\n    if (keys.length === 0) {\n      throw new Error(\"Splines require at least one key.\");\n    }\n    if (Array.isArray(keys[0])) {\n      throw new Error(\"You are trying to pass an array to the spline constructor, which is not supported. \" + \"Try to spread the array into the constructor instead.\");\n    }\n    this.keys = keys;\n  }\n  /**\r\n   * Evaluates the spline at the given time.\r\n   */\n  Spline.prototype.evaluate = function (time) {\n    if (this.keys.length === 0) {\n      throw new Error(\"Attempt to evaluate a spline with no keys.\");\n    }\n    if (this.keys.length === 1) {\n      // The spline only contains one key, therefore is constant.\n      return this.keys[0].value;\n    }\n    // Sort the keys and figure out the first key above the passed time.\n    var ascendingKeys = this.keys.sort(function (a, b) {\n      return a.time - b.time;\n    });\n    var upperKeyIndex = ascendingKeys.findIndex(function (g) {\n      return g.time > time;\n    });\n    // If the found index is either 0 or -1, the specified time falls out\n    // of the range of the supplied keys. In that case, the value of the\n    // nearest applicant key is returned.\n    if (upperKeyIndex === 0) {\n      return ascendingKeys[0].value;\n    }\n    if (upperKeyIndex === -1) {\n      return ascendingKeys[ascendingKeys.length - 1].value;\n    }\n    // Otherwise, find the bounding keys, and extrapolate the time between\n    // the two. This is then used to interpolate between the two keys,\n    // using the provided implementation.\n    var lowerKey = ascendingKeys[upperKeyIndex - 1];\n    var upperKey = ascendingKeys[upperKeyIndex];\n    var containedTime = math_1.invlerp(lowerKey.time, upperKey.time, time);\n    return this.interpolate(lowerKey.value, upperKey.value, containedTime);\n  };\n  return Spline;\n}();\nexports.Spline = Spline;","map":{"version":3,"names":["Object","defineProperty","exports","value","Spline","math_1","require","keys","_i","arguments","length","Error","Array","isArray","prototype","evaluate","time","ascendingKeys","sort","a","b","upperKeyIndex","findIndex","g","lowerKey","upperKey","containedTime","invlerp","interpolate"],"sources":["C:/works/react-test/node_modules/party-js/lib/components/spline.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Spline = void 0;\r\nvar math_1 = require(\"../systems/math\");\r\n/**\r\n * Represents a spline that can be used to continueously evaluate a function\r\n * between keys. The base implementation is kept generic, so the functionality\r\n * can easily be implemented for similar constructs, such as gradients.\r\n */\r\nvar Spline = /** @class */ (function () {\r\n    /**\r\n     * Creates a new spline instance, using the specified keys.\r\n     * Note that you have to pass at least one key.\r\n     */\r\n    function Spline() {\r\n        var keys = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            keys[_i] = arguments[_i];\r\n        }\r\n        if (keys.length === 0) {\r\n            throw new Error(\"Splines require at least one key.\");\r\n        }\r\n        if (Array.isArray(keys[0])) {\r\n            throw new Error(\"You are trying to pass an array to the spline constructor, which is not supported. \" +\r\n                \"Try to spread the array into the constructor instead.\");\r\n        }\r\n        this.keys = keys;\r\n    }\r\n    /**\r\n     * Evaluates the spline at the given time.\r\n     */\r\n    Spline.prototype.evaluate = function (time) {\r\n        if (this.keys.length === 0) {\r\n            throw new Error(\"Attempt to evaluate a spline with no keys.\");\r\n        }\r\n        if (this.keys.length === 1) {\r\n            // The spline only contains one key, therefore is constant.\r\n            return this.keys[0].value;\r\n        }\r\n        // Sort the keys and figure out the first key above the passed time.\r\n        var ascendingKeys = this.keys.sort(function (a, b) { return a.time - b.time; });\r\n        var upperKeyIndex = ascendingKeys.findIndex(function (g) { return g.time > time; });\r\n        // If the found index is either 0 or -1, the specified time falls out\r\n        // of the range of the supplied keys. In that case, the value of the\r\n        // nearest applicant key is returned.\r\n        if (upperKeyIndex === 0) {\r\n            return ascendingKeys[0].value;\r\n        }\r\n        if (upperKeyIndex === -1) {\r\n            return ascendingKeys[ascendingKeys.length - 1].value;\r\n        }\r\n        // Otherwise, find the bounding keys, and extrapolate the time between\r\n        // the two. This is then used to interpolate between the two keys,\r\n        // using the provided implementation.\r\n        var lowerKey = ascendingKeys[upperKeyIndex - 1];\r\n        var upperKey = ascendingKeys[upperKeyIndex];\r\n        var containedTime = math_1.invlerp(lowerKey.time, upperKey.time, time);\r\n        return this.interpolate(lowerKey.value, upperKey.value, containedTime);\r\n    };\r\n    return Spline;\r\n}());\r\nexports.Spline = Spline;\r\n"],"mappings":"AAAA,YAAY;;AACZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,MAAM,GAAG,KAAK,CAAC;AACvB,IAAIC,MAAM,GAAGC,OAAO,CAAC,iBAAiB,CAAC;AACvC;AACA;AACA;AACA;AACA;AACA,IAAIF,MAAM,GAAG,aAAe,YAAY;EACpC;AACJ;AACA;AACA;EACI,SAASA,MAAMA,CAAA,EAAG;IACd,IAAIG,IAAI,GAAG,EAAE;IACb,KAAK,IAAIC,EAAE,GAAG,CAAC,EAAEA,EAAE,GAAGC,SAAS,CAACC,MAAM,EAAEF,EAAE,EAAE,EAAE;MAC1CD,IAAI,CAACC,EAAE,CAAC,GAAGC,SAAS,CAACD,EAAE,CAAC;IAC5B;IACA,IAAID,IAAI,CAACG,MAAM,KAAK,CAAC,EAAE;MACnB,MAAM,IAAIC,KAAK,CAAC,mCAAmC,CAAC;IACxD;IACA,IAAIC,KAAK,CAACC,OAAO,CAACN,IAAI,CAAC,CAAC,CAAC,CAAC,EAAE;MACxB,MAAM,IAAII,KAAK,CAAC,qFAAqF,GACjG,uDAAuD,CAAC;IAChE;IACA,IAAI,CAACJ,IAAI,GAAGA,IAAI;EACpB;EACA;AACJ;AACA;EACIH,MAAM,CAACU,SAAS,CAACC,QAAQ,GAAG,UAAUC,IAAI,EAAE;IACxC,IAAI,IAAI,CAACT,IAAI,CAACG,MAAM,KAAK,CAAC,EAAE;MACxB,MAAM,IAAIC,KAAK,CAAC,4CAA4C,CAAC;IACjE;IACA,IAAI,IAAI,CAACJ,IAAI,CAACG,MAAM,KAAK,CAAC,EAAE;MACxB;MACA,OAAO,IAAI,CAACH,IAAI,CAAC,CAAC,CAAC,CAACJ,KAAK;IAC7B;IACA;IACA,IAAIc,aAAa,GAAG,IAAI,CAACV,IAAI,CAACW,IAAI,CAAC,UAAUC,CAAC,EAAEC,CAAC,EAAE;MAAE,OAAOD,CAAC,CAACH,IAAI,GAAGI,CAAC,CAACJ,IAAI;IAAE,CAAC,CAAC;IAC/E,IAAIK,aAAa,GAAGJ,aAAa,CAACK,SAAS,CAAC,UAAUC,CAAC,EAAE;MAAE,OAAOA,CAAC,CAACP,IAAI,GAAGA,IAAI;IAAE,CAAC,CAAC;IACnF;IACA;IACA;IACA,IAAIK,aAAa,KAAK,CAAC,EAAE;MACrB,OAAOJ,aAAa,CAAC,CAAC,CAAC,CAACd,KAAK;IACjC;IACA,IAAIkB,aAAa,KAAK,CAAC,CAAC,EAAE;MACtB,OAAOJ,aAAa,CAACA,aAAa,CAACP,MAAM,GAAG,CAAC,CAAC,CAACP,KAAK;IACxD;IACA;IACA;IACA;IACA,IAAIqB,QAAQ,GAAGP,aAAa,CAACI,aAAa,GAAG,CAAC,CAAC;IAC/C,IAAII,QAAQ,GAAGR,aAAa,CAACI,aAAa,CAAC;IAC3C,IAAIK,aAAa,GAAGrB,MAAM,CAACsB,OAAO,CAACH,QAAQ,CAACR,IAAI,EAAES,QAAQ,CAACT,IAAI,EAAEA,IAAI,CAAC;IACtE,OAAO,IAAI,CAACY,WAAW,CAACJ,QAAQ,CAACrB,KAAK,EAAEsB,QAAQ,CAACtB,KAAK,EAAEuB,aAAa,CAAC;EAC1E,CAAC;EACD,OAAOtB,MAAM;AACjB,CAAC,CAAC,CAAE;AACJF,OAAO,CAACE,MAAM,GAAGA,MAAM"},"metadata":{},"sourceType":"script","externalDependencies":[]}