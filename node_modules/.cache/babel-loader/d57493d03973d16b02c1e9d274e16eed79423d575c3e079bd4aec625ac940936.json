{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Emitter = void 0;\nvar vector_1 = require(\"../components/vector\");\nvar settings_1 = require(\"../settings\");\nvar variation_1 = require(\"../systems/variation\");\nvar config_1 = require(\"../util/config\");\nvar options_1 = require(\"./options\");\nvar particle_1 = require(\"./particle\");\n/**\r\n * Represents an emitter that is responsible for spawning and updating particles.\r\n *\r\n * Particles themselves are just data-holders, with the system acting upon them and\r\n * modifying them. The modifications are done mainly via modules, that use the\r\n * particle's data together with some function to apply temporal transitions.\r\n *\r\n * @see Particle\r\n * @see ParticleModifierModule\r\n */\nvar Emitter = /** @class */function () {\n  /**\r\n   * Creates a new emitter, using default options.\r\n   */\n  function Emitter(options) {\n    /**\r\n     * The particles currently contained within the system.\r\n     */\n    this.particles = [];\n    this.currentLoop = 0; // The current loop index.\n    this.durationTimer = 0; // Measures the current runtime duration, to allow loops to reset.\n    this.emissionTimer = 0; // Measures the current emission timer, to allow spawning particles in intervals.\n    this.attemptedBurstIndices = []; // The indices of the particle bursts that were attempted this loop.\n    this.options = config_1.overrideDefaults(options_1.getDefaultEmitterOptions(), options === null || options === void 0 ? void 0 : options.emitterOptions);\n    this.emission = config_1.overrideDefaults(options_1.getDefaultEmissionOptions(), options === null || options === void 0 ? void 0 : options.emissionOptions);\n    this.renderer = config_1.overrideDefaults(options_1.getDefaultRendererOptions(), options === null || options === void 0 ? void 0 : options.rendererOptions);\n  }\n  Object.defineProperty(Emitter.prototype, \"isExpired\", {\n    /**\r\n     * Checks if the emitter is already expired and can be removed.\r\n     * Expired emitters do not emit new particles.\r\n     */\n    get: function () {\n      return this.options.loops >= 0 && this.currentLoop >= this.options.loops;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Emitter.prototype, \"canRemove\", {\n    /**\r\n     * Checks if the emitter can safely be removed.\r\n     * This is true if no more particles are active.\r\n     */\n    get: function () {\n      return this.particles.length === 0;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Clears all particles inside the emitter.\r\n   *\r\n   * @returns The number of cleared particles.\r\n   */\n  Emitter.prototype.clearParticles = function () {\n    return this.particles.splice(0).length;\n  };\n  /**\r\n   * Processes a tick of the emitter, using the elapsed time.\r\n   *\r\n   * @remarks\r\n   * This handles a few things, namely:\r\n   * - Incrementing the duration timer and potentially incrementing the loop.\r\n   * - Handling particle bursts & emissions.\r\n   * - Despawning particles conditionally.\r\n   *\r\n   * @param delta The time, in seconds, passed since the last tick.\r\n   */\n  Emitter.prototype.tick = function (delta) {\n    if (!this.isExpired) {\n      this.durationTimer += delta;\n      if (this.durationTimer >= this.options.duration) {\n        this.currentLoop++;\n        // To start a new loop, the duration timer and attempted bursts are reset.\n        this.durationTimer = 0;\n        this.attemptedBurstIndices = [];\n      }\n      // We need to check the expiry again, in case the added loop or duration changed something.\n      if (!this.isExpired) {\n        // Iterate over the bursts, attempting to execute them if the time is ready.\n        var burstIndex = 0;\n        for (var _i = 0, _a = this.emission.bursts; _i < _a.length; _i++) {\n          var burst = _a[_i];\n          if (burst.time <= this.durationTimer) {\n            // Has the burst already been attempted? If not ...\n            if (!this.attemptedBurstIndices.includes(burstIndex)) {\n              // Perform the burst, emitting a variable amount of particles.\n              var count = variation_1.evaluateVariation(burst.count);\n              for (var i = 0; i < count; i++) {\n                this.emitParticle();\n              }\n              // Mark the burst as attempted.\n              this.attemptedBurstIndices.push(burstIndex);\n            }\n          }\n          burstIndex++;\n        }\n        // Handle the 'emission over time'. By using a while-loop instead of a simple\n        // if-condition, we take high deltas into account, and ensure that the correct\n        // number of particles will consistently be emitted.\n        this.emissionTimer += delta;\n        var delay = 1 / this.emission.rate;\n        while (this.emissionTimer > delay) {\n          this.emissionTimer -= delay;\n          this.emitParticle();\n        }\n      }\n    }\n    var _loop_1 = function (i) {\n      var particle = this_1.particles[i];\n      this_1.tickParticle(particle, delta);\n      // Particles should be despawned (i.e. removed from the collection) if any of\n      // the despawning rules apply to them.\n      if (this_1.options.despawningRules.some(function (rule) {\n        return rule(particle);\n      })) {\n        this_1.particles.splice(i, 1);\n      }\n    };\n    var this_1 = this;\n    for (var i = this.particles.length - 1; i >= 0; i--) {\n      _loop_1(i);\n    }\n  };\n  /**\r\n   * Performs an internal tick for the particle.\r\n   *\r\n   * @remarks\r\n   * This method controls the particle's lifetime, location and velocity, according\r\n   * to the elapsed delta and the configuration. Additionally, each of the emitter's\r\n   * modules is applied to the particle.\r\n   *\r\n   * @param particle The particle to apply the tick for.\r\n   * @param delta The time, in seconds, passed since the last tick.\r\n   */\n  Emitter.prototype.tickParticle = function (particle, delta) {\n    particle.lifetime -= delta;\n    if (this.options.useGravity) {\n      // Apply gravitational acceleration to the particle.\n      particle.velocity = particle.velocity.add(vector_1.Vector.up.scale(settings_1.settings.gravity * delta));\n    }\n    // Apply the particle's velocity to its location.\n    particle.location = particle.location.add(particle.velocity.scale(delta));\n    // Apply the modules to the particle.\n    for (var _i = 0, _a = this.options.modules; _i < _a.length; _i++) {\n      var moduleFunction = _a[_i];\n      moduleFunction(particle);\n    }\n  };\n  /**\r\n   * Emits a particle using the registered settings.\r\n   * Also may despawn a particle if the maximum number of particles is exceeded.\r\n   */\n  Emitter.prototype.emitParticle = function () {\n    var particle = new particle_1.Particle({\n      location: this.emission.sourceSampler(),\n      lifetime: variation_1.evaluateVariation(this.emission.initialLifetime),\n      velocity: vector_1.Vector.from2dAngle(variation_1.evaluateVariation(this.emission.angle)).scale(variation_1.evaluateVariation(this.emission.initialSpeed)),\n      size: variation_1.evaluateVariation(this.emission.initialSize),\n      rotation: variation_1.evaluateVariation(this.emission.initialRotation),\n      color: variation_1.evaluateVariation(this.emission.initialColor)\n    });\n    this.particles.push(particle);\n    // Ensure that no more particles than 'maxParticles' can exist.\n    if (this.particles.length > this.options.maxParticles) {\n      this.particles.shift();\n    }\n    return particle;\n  };\n  return Emitter;\n}();\nexports.Emitter = Emitter;","map":{"version":3,"names":["Object","defineProperty","exports","value","Emitter","vector_1","require","settings_1","variation_1","config_1","options_1","particle_1","options","particles","currentLoop","durationTimer","emissionTimer","attemptedBurstIndices","overrideDefaults","getDefaultEmitterOptions","emitterOptions","emission","getDefaultEmissionOptions","emissionOptions","renderer","getDefaultRendererOptions","rendererOptions","prototype","get","loops","enumerable","configurable","length","clearParticles","splice","tick","delta","isExpired","duration","burstIndex","_i","_a","bursts","burst","time","includes","count","evaluateVariation","i","emitParticle","push","delay","rate","_loop_1","particle","this_1","tickParticle","despawningRules","some","rule","lifetime","useGravity","velocity","add","Vector","up","scale","settings","gravity","location","modules","moduleFunction","Particle","sourceSampler","initialLifetime","from2dAngle","angle","initialSpeed","size","initialSize","rotation","initialRotation","color","initialColor","maxParticles","shift"],"sources":["C:/works/react-test/node_modules/party-js/lib/particles/emitter.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Emitter = void 0;\r\nvar vector_1 = require(\"../components/vector\");\r\nvar settings_1 = require(\"../settings\");\r\nvar variation_1 = require(\"../systems/variation\");\r\nvar config_1 = require(\"../util/config\");\r\nvar options_1 = require(\"./options\");\r\nvar particle_1 = require(\"./particle\");\r\n/**\r\n * Represents an emitter that is responsible for spawning and updating particles.\r\n *\r\n * Particles themselves are just data-holders, with the system acting upon them and\r\n * modifying them. The modifications are done mainly via modules, that use the\r\n * particle's data together with some function to apply temporal transitions.\r\n *\r\n * @see Particle\r\n * @see ParticleModifierModule\r\n */\r\nvar Emitter = /** @class */ (function () {\r\n    /**\r\n     * Creates a new emitter, using default options.\r\n     */\r\n    function Emitter(options) {\r\n        /**\r\n         * The particles currently contained within the system.\r\n         */\r\n        this.particles = [];\r\n        this.currentLoop = 0; // The current loop index.\r\n        this.durationTimer = 0; // Measures the current runtime duration, to allow loops to reset.\r\n        this.emissionTimer = 0; // Measures the current emission timer, to allow spawning particles in intervals.\r\n        this.attemptedBurstIndices = []; // The indices of the particle bursts that were attempted this loop.\r\n        this.options = config_1.overrideDefaults(options_1.getDefaultEmitterOptions(), options === null || options === void 0 ? void 0 : options.emitterOptions);\r\n        this.emission = config_1.overrideDefaults(options_1.getDefaultEmissionOptions(), options === null || options === void 0 ? void 0 : options.emissionOptions);\r\n        this.renderer = config_1.overrideDefaults(options_1.getDefaultRendererOptions(), options === null || options === void 0 ? void 0 : options.rendererOptions);\r\n    }\r\n    Object.defineProperty(Emitter.prototype, \"isExpired\", {\r\n        /**\r\n         * Checks if the emitter is already expired and can be removed.\r\n         * Expired emitters do not emit new particles.\r\n         */\r\n        get: function () {\r\n            return (this.options.loops >= 0 && this.currentLoop >= this.options.loops);\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Emitter.prototype, \"canRemove\", {\r\n        /**\r\n         * Checks if the emitter can safely be removed.\r\n         * This is true if no more particles are active.\r\n         */\r\n        get: function () {\r\n            return this.particles.length === 0;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Clears all particles inside the emitter.\r\n     *\r\n     * @returns The number of cleared particles.\r\n     */\r\n    Emitter.prototype.clearParticles = function () {\r\n        return this.particles.splice(0).length;\r\n    };\r\n    /**\r\n     * Processes a tick of the emitter, using the elapsed time.\r\n     *\r\n     * @remarks\r\n     * This handles a few things, namely:\r\n     * - Incrementing the duration timer and potentially incrementing the loop.\r\n     * - Handling particle bursts & emissions.\r\n     * - Despawning particles conditionally.\r\n     *\r\n     * @param delta The time, in seconds, passed since the last tick.\r\n     */\r\n    Emitter.prototype.tick = function (delta) {\r\n        if (!this.isExpired) {\r\n            this.durationTimer += delta;\r\n            if (this.durationTimer >= this.options.duration) {\r\n                this.currentLoop++;\r\n                // To start a new loop, the duration timer and attempted bursts are reset.\r\n                this.durationTimer = 0;\r\n                this.attemptedBurstIndices = [];\r\n            }\r\n            // We need to check the expiry again, in case the added loop or duration changed something.\r\n            if (!this.isExpired) {\r\n                // Iterate over the bursts, attempting to execute them if the time is ready.\r\n                var burstIndex = 0;\r\n                for (var _i = 0, _a = this.emission.bursts; _i < _a.length; _i++) {\r\n                    var burst = _a[_i];\r\n                    if (burst.time <= this.durationTimer) {\r\n                        // Has the burst already been attempted? If not ...\r\n                        if (!this.attemptedBurstIndices.includes(burstIndex)) {\r\n                            // Perform the burst, emitting a variable amount of particles.\r\n                            var count = variation_1.evaluateVariation(burst.count);\r\n                            for (var i = 0; i < count; i++) {\r\n                                this.emitParticle();\r\n                            }\r\n                            // Mark the burst as attempted.\r\n                            this.attemptedBurstIndices.push(burstIndex);\r\n                        }\r\n                    }\r\n                    burstIndex++;\r\n                }\r\n                // Handle the 'emission over time'. By using a while-loop instead of a simple\r\n                // if-condition, we take high deltas into account, and ensure that the correct\r\n                // number of particles will consistently be emitted.\r\n                this.emissionTimer += delta;\r\n                var delay = 1 / this.emission.rate;\r\n                while (this.emissionTimer > delay) {\r\n                    this.emissionTimer -= delay;\r\n                    this.emitParticle();\r\n                }\r\n            }\r\n        }\r\n        var _loop_1 = function (i) {\r\n            var particle = this_1.particles[i];\r\n            this_1.tickParticle(particle, delta);\r\n            // Particles should be despawned (i.e. removed from the collection) if any of\r\n            // the despawning rules apply to them.\r\n            if (this_1.options.despawningRules.some(function (rule) { return rule(particle); })) {\r\n                this_1.particles.splice(i, 1);\r\n            }\r\n        };\r\n        var this_1 = this;\r\n        for (var i = this.particles.length - 1; i >= 0; i--) {\r\n            _loop_1(i);\r\n        }\r\n    };\r\n    /**\r\n     * Performs an internal tick for the particle.\r\n     *\r\n     * @remarks\r\n     * This method controls the particle's lifetime, location and velocity, according\r\n     * to the elapsed delta and the configuration. Additionally, each of the emitter's\r\n     * modules is applied to the particle.\r\n     *\r\n     * @param particle The particle to apply the tick for.\r\n     * @param delta The time, in seconds, passed since the last tick.\r\n     */\r\n    Emitter.prototype.tickParticle = function (particle, delta) {\r\n        particle.lifetime -= delta;\r\n        if (this.options.useGravity) {\r\n            // Apply gravitational acceleration to the particle.\r\n            particle.velocity = particle.velocity.add(vector_1.Vector.up.scale(settings_1.settings.gravity * delta));\r\n        }\r\n        // Apply the particle's velocity to its location.\r\n        particle.location = particle.location.add(particle.velocity.scale(delta));\r\n        // Apply the modules to the particle.\r\n        for (var _i = 0, _a = this.options.modules; _i < _a.length; _i++) {\r\n            var moduleFunction = _a[_i];\r\n            moduleFunction(particle);\r\n        }\r\n    };\r\n    /**\r\n     * Emits a particle using the registered settings.\r\n     * Also may despawn a particle if the maximum number of particles is exceeded.\r\n     */\r\n    Emitter.prototype.emitParticle = function () {\r\n        var particle = new particle_1.Particle({\r\n            location: this.emission.sourceSampler(),\r\n            lifetime: variation_1.evaluateVariation(this.emission.initialLifetime),\r\n            velocity: vector_1.Vector.from2dAngle(variation_1.evaluateVariation(this.emission.angle)).scale(variation_1.evaluateVariation(this.emission.initialSpeed)),\r\n            size: variation_1.evaluateVariation(this.emission.initialSize),\r\n            rotation: variation_1.evaluateVariation(this.emission.initialRotation),\r\n            color: variation_1.evaluateVariation(this.emission.initialColor),\r\n        });\r\n        this.particles.push(particle);\r\n        // Ensure that no more particles than 'maxParticles' can exist.\r\n        if (this.particles.length > this.options.maxParticles) {\r\n            this.particles.shift();\r\n        }\r\n        return particle;\r\n    };\r\n    return Emitter;\r\n}());\r\nexports.Emitter = Emitter;\r\n"],"mappings":"AAAA,YAAY;;AACZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,OAAO,GAAG,KAAK,CAAC;AACxB,IAAIC,QAAQ,GAAGC,OAAO,CAAC,sBAAsB,CAAC;AAC9C,IAAIC,UAAU,GAAGD,OAAO,CAAC,aAAa,CAAC;AACvC,IAAIE,WAAW,GAAGF,OAAO,CAAC,sBAAsB,CAAC;AACjD,IAAIG,QAAQ,GAAGH,OAAO,CAAC,gBAAgB,CAAC;AACxC,IAAII,SAAS,GAAGJ,OAAO,CAAC,WAAW,CAAC;AACpC,IAAIK,UAAU,GAAGL,OAAO,CAAC,YAAY,CAAC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIF,OAAO,GAAG,aAAe,YAAY;EACrC;AACJ;AACA;EACI,SAASA,OAAOA,CAACQ,OAAO,EAAE;IACtB;AACR;AACA;IACQ,IAAI,CAACC,SAAS,GAAG,EAAE;IACnB,IAAI,CAACC,WAAW,GAAG,CAAC,CAAC,CAAC;IACtB,IAAI,CAACC,aAAa,GAAG,CAAC,CAAC,CAAC;IACxB,IAAI,CAACC,aAAa,GAAG,CAAC,CAAC,CAAC;IACxB,IAAI,CAACC,qBAAqB,GAAG,EAAE,CAAC,CAAC;IACjC,IAAI,CAACL,OAAO,GAAGH,QAAQ,CAACS,gBAAgB,CAACR,SAAS,CAACS,wBAAwB,CAAC,CAAC,EAAEP,OAAO,KAAK,IAAI,IAAIA,OAAO,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,OAAO,CAACQ,cAAc,CAAC;IACxJ,IAAI,CAACC,QAAQ,GAAGZ,QAAQ,CAACS,gBAAgB,CAACR,SAAS,CAACY,yBAAyB,CAAC,CAAC,EAAEV,OAAO,KAAK,IAAI,IAAIA,OAAO,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,OAAO,CAACW,eAAe,CAAC;IAC3J,IAAI,CAACC,QAAQ,GAAGf,QAAQ,CAACS,gBAAgB,CAACR,SAAS,CAACe,yBAAyB,CAAC,CAAC,EAAEb,OAAO,KAAK,IAAI,IAAIA,OAAO,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,OAAO,CAACc,eAAe,CAAC;EAC/J;EACA1B,MAAM,CAACC,cAAc,CAACG,OAAO,CAACuB,SAAS,EAAE,WAAW,EAAE;IAClD;AACR;AACA;AACA;IACQC,GAAG,EAAE,SAAAA,CAAA,EAAY;MACb,OAAQ,IAAI,CAAChB,OAAO,CAACiB,KAAK,IAAI,CAAC,IAAI,IAAI,CAACf,WAAW,IAAI,IAAI,CAACF,OAAO,CAACiB,KAAK;IAC7E,CAAC;IACDC,UAAU,EAAE,KAAK;IACjBC,YAAY,EAAE;EAClB,CAAC,CAAC;EACF/B,MAAM,CAACC,cAAc,CAACG,OAAO,CAACuB,SAAS,EAAE,WAAW,EAAE;IAClD;AACR;AACA;AACA;IACQC,GAAG,EAAE,SAAAA,CAAA,EAAY;MACb,OAAO,IAAI,CAACf,SAAS,CAACmB,MAAM,KAAK,CAAC;IACtC,CAAC;IACDF,UAAU,EAAE,KAAK;IACjBC,YAAY,EAAE;EAClB,CAAC,CAAC;EACF;AACJ;AACA;AACA;AACA;EACI3B,OAAO,CAACuB,SAAS,CAACM,cAAc,GAAG,YAAY;IAC3C,OAAO,IAAI,CAACpB,SAAS,CAACqB,MAAM,CAAC,CAAC,CAAC,CAACF,MAAM;EAC1C,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI5B,OAAO,CAACuB,SAAS,CAACQ,IAAI,GAAG,UAAUC,KAAK,EAAE;IACtC,IAAI,CAAC,IAAI,CAACC,SAAS,EAAE;MACjB,IAAI,CAACtB,aAAa,IAAIqB,KAAK;MAC3B,IAAI,IAAI,CAACrB,aAAa,IAAI,IAAI,CAACH,OAAO,CAAC0B,QAAQ,EAAE;QAC7C,IAAI,CAACxB,WAAW,EAAE;QAClB;QACA,IAAI,CAACC,aAAa,GAAG,CAAC;QACtB,IAAI,CAACE,qBAAqB,GAAG,EAAE;MACnC;MACA;MACA,IAAI,CAAC,IAAI,CAACoB,SAAS,EAAE;QACjB;QACA,IAAIE,UAAU,GAAG,CAAC;QAClB,KAAK,IAAIC,EAAE,GAAG,CAAC,EAAEC,EAAE,GAAG,IAAI,CAACpB,QAAQ,CAACqB,MAAM,EAAEF,EAAE,GAAGC,EAAE,CAACT,MAAM,EAAEQ,EAAE,EAAE,EAAE;UAC9D,IAAIG,KAAK,GAAGF,EAAE,CAACD,EAAE,CAAC;UAClB,IAAIG,KAAK,CAACC,IAAI,IAAI,IAAI,CAAC7B,aAAa,EAAE;YAClC;YACA,IAAI,CAAC,IAAI,CAACE,qBAAqB,CAAC4B,QAAQ,CAACN,UAAU,CAAC,EAAE;cAClD;cACA,IAAIO,KAAK,GAAGtC,WAAW,CAACuC,iBAAiB,CAACJ,KAAK,CAACG,KAAK,CAAC;cACtD,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,KAAK,EAAEE,CAAC,EAAE,EAAE;gBAC5B,IAAI,CAACC,YAAY,CAAC,CAAC;cACvB;cACA;cACA,IAAI,CAAChC,qBAAqB,CAACiC,IAAI,CAACX,UAAU,CAAC;YAC/C;UACJ;UACAA,UAAU,EAAE;QAChB;QACA;QACA;QACA;QACA,IAAI,CAACvB,aAAa,IAAIoB,KAAK;QAC3B,IAAIe,KAAK,GAAG,CAAC,GAAG,IAAI,CAAC9B,QAAQ,CAAC+B,IAAI;QAClC,OAAO,IAAI,CAACpC,aAAa,GAAGmC,KAAK,EAAE;UAC/B,IAAI,CAACnC,aAAa,IAAImC,KAAK;UAC3B,IAAI,CAACF,YAAY,CAAC,CAAC;QACvB;MACJ;IACJ;IACA,IAAII,OAAO,GAAG,SAAAA,CAAUL,CAAC,EAAE;MACvB,IAAIM,QAAQ,GAAGC,MAAM,CAAC1C,SAAS,CAACmC,CAAC,CAAC;MAClCO,MAAM,CAACC,YAAY,CAACF,QAAQ,EAAElB,KAAK,CAAC;MACpC;MACA;MACA,IAAImB,MAAM,CAAC3C,OAAO,CAAC6C,eAAe,CAACC,IAAI,CAAC,UAAUC,IAAI,EAAE;QAAE,OAAOA,IAAI,CAACL,QAAQ,CAAC;MAAE,CAAC,CAAC,EAAE;QACjFC,MAAM,CAAC1C,SAAS,CAACqB,MAAM,CAACc,CAAC,EAAE,CAAC,CAAC;MACjC;IACJ,CAAC;IACD,IAAIO,MAAM,GAAG,IAAI;IACjB,KAAK,IAAIP,CAAC,GAAG,IAAI,CAACnC,SAAS,CAACmB,MAAM,GAAG,CAAC,EAAEgB,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;MACjDK,OAAO,CAACL,CAAC,CAAC;IACd;EACJ,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI5C,OAAO,CAACuB,SAAS,CAAC6B,YAAY,GAAG,UAAUF,QAAQ,EAAElB,KAAK,EAAE;IACxDkB,QAAQ,CAACM,QAAQ,IAAIxB,KAAK;IAC1B,IAAI,IAAI,CAACxB,OAAO,CAACiD,UAAU,EAAE;MACzB;MACAP,QAAQ,CAACQ,QAAQ,GAAGR,QAAQ,CAACQ,QAAQ,CAACC,GAAG,CAAC1D,QAAQ,CAAC2D,MAAM,CAACC,EAAE,CAACC,KAAK,CAAC3D,UAAU,CAAC4D,QAAQ,CAACC,OAAO,GAAGhC,KAAK,CAAC,CAAC;IAC5G;IACA;IACAkB,QAAQ,CAACe,QAAQ,GAAGf,QAAQ,CAACe,QAAQ,CAACN,GAAG,CAACT,QAAQ,CAACQ,QAAQ,CAACI,KAAK,CAAC9B,KAAK,CAAC,CAAC;IACzE;IACA,KAAK,IAAII,EAAE,GAAG,CAAC,EAAEC,EAAE,GAAG,IAAI,CAAC7B,OAAO,CAAC0D,OAAO,EAAE9B,EAAE,GAAGC,EAAE,CAACT,MAAM,EAAEQ,EAAE,EAAE,EAAE;MAC9D,IAAI+B,cAAc,GAAG9B,EAAE,CAACD,EAAE,CAAC;MAC3B+B,cAAc,CAACjB,QAAQ,CAAC;IAC5B;EACJ,CAAC;EACD;AACJ;AACA;AACA;EACIlD,OAAO,CAACuB,SAAS,CAACsB,YAAY,GAAG,YAAY;IACzC,IAAIK,QAAQ,GAAG,IAAI3C,UAAU,CAAC6D,QAAQ,CAAC;MACnCH,QAAQ,EAAE,IAAI,CAAChD,QAAQ,CAACoD,aAAa,CAAC,CAAC;MACvCb,QAAQ,EAAEpD,WAAW,CAACuC,iBAAiB,CAAC,IAAI,CAAC1B,QAAQ,CAACqD,eAAe,CAAC;MACtEZ,QAAQ,EAAEzD,QAAQ,CAAC2D,MAAM,CAACW,WAAW,CAACnE,WAAW,CAACuC,iBAAiB,CAAC,IAAI,CAAC1B,QAAQ,CAACuD,KAAK,CAAC,CAAC,CAACV,KAAK,CAAC1D,WAAW,CAACuC,iBAAiB,CAAC,IAAI,CAAC1B,QAAQ,CAACwD,YAAY,CAAC,CAAC;MAC1JC,IAAI,EAAEtE,WAAW,CAACuC,iBAAiB,CAAC,IAAI,CAAC1B,QAAQ,CAAC0D,WAAW,CAAC;MAC9DC,QAAQ,EAAExE,WAAW,CAACuC,iBAAiB,CAAC,IAAI,CAAC1B,QAAQ,CAAC4D,eAAe,CAAC;MACtEC,KAAK,EAAE1E,WAAW,CAACuC,iBAAiB,CAAC,IAAI,CAAC1B,QAAQ,CAAC8D,YAAY;IACnE,CAAC,CAAC;IACF,IAAI,CAACtE,SAAS,CAACqC,IAAI,CAACI,QAAQ,CAAC;IAC7B;IACA,IAAI,IAAI,CAACzC,SAAS,CAACmB,MAAM,GAAG,IAAI,CAACpB,OAAO,CAACwE,YAAY,EAAE;MACnD,IAAI,CAACvE,SAAS,CAACwE,KAAK,CAAC,CAAC;IAC1B;IACA,OAAO/B,QAAQ;EACnB,CAAC;EACD,OAAOlD,OAAO;AAClB,CAAC,CAAC,CAAE;AACJF,OAAO,CAACE,OAAO,GAAGA,OAAO"},"metadata":{},"sourceType":"script","externalDependencies":[]}