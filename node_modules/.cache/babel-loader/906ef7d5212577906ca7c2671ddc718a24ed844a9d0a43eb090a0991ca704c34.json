{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ModuleBuilder = void 0;\nvar components_1 = require(\"../components\");\n/**\r\n * Represents a builder for particle modules. Returns an evaluatable module\r\n * function, that can be consumed by emitters.\r\n *\r\n * @remarks\r\n * Not all properties can be driven. TypeScript will validate this at compile time,\r\n * but no internal validation is performed due to performance reasons. Also, note\r\n * that the driving factor is \"lifetime\" by default.\r\n *\r\n * @example\r\n * ```ts\r\n * new ModuleBuilder()\r\n *     .drive(\"size\")\r\n *     .by((t) => t * 2)\r\n *     .through(\"lifetime\")\r\n *     .build();\r\n * ```\r\n */\nvar ModuleBuilder = /** @class */function () {\n  function ModuleBuilder() {\n    /**\r\n     * The factor driving the built function.\r\n     *\r\n     * @defaultValue \"lifetime\"\r\n     */\n    this.factor = \"lifetime\";\n    this.isRelative = false;\n  }\n  /**\r\n   * Specifies the key in the particle that should be driven.\r\n   *\r\n   * @remarks\r\n   * Note that not all of a particle's properties are drivable through modules. If you\r\n   * need full control of a particle inside of a module, you can use a module function directly.\r\n   *\r\n   * @returns The chained builder instance.\r\n   */\n  ModuleBuilder.prototype.drive = function (key) {\n    this.driverKey = key;\n    return this;\n  };\n  /**\r\n   * Specifies the factor to drive the evaluated value by. Supports \"lifetime\" and \"size\".\r\n   *\r\n   * @returns The chained builder instance.\r\n   */\n  ModuleBuilder.prototype.through = function (factor) {\n    this.factor = factor;\n    return this;\n  };\n  /**\r\n   * Specifies the value to drive the module behaviour by. This can be a constant,\r\n   * a spline or an evaluable function. Note that in the last case, the driving\r\n   * factor is passed as a parameter.\r\n   *\r\n   * @returns The chained builder instance.\r\n   */\n  ModuleBuilder.prototype.by = function (driver) {\n    this.driverValue = driver;\n    return this;\n  };\n  /**\r\n   * Specifies that the module function is supposed to act relative to the\r\n   * properties initial value.\r\n   *\r\n   * @remarks\r\n   * Note that this is only possible if an \"initial*\" property exists on the\r\n   * particle object. The operation applied to the initial and new value\r\n   * is dependant on their type:\r\n   * - `Vector`: Both vectors are added.\r\n   * - `number`: Both numbers are multiplied.\r\n   *\r\n   * For more advanced relative customizations, consider using the particle\r\n   * object in the driver value function instead, like:\r\n   * ```ts\r\n   * .by((t, p) => p.initialSize + t * 2);\r\n   * ```\r\n   */\n  ModuleBuilder.prototype.relative = function (isRelative) {\n    if (isRelative === void 0) {\n      isRelative = true;\n    }\n    this.isRelative = isRelative;\n    return this;\n  };\n  /**\r\n   * Consumes the builder and returns an evaluatable module function.\r\n   *\r\n   * @remarks\r\n   * Note that you need to specify the driving key and value, otherwise an error\r\n   * will be thrown.\r\n   */\n  ModuleBuilder.prototype.build = function () {\n    var _this = this;\n    if (typeof this.driverKey === \"undefined\") {\n      throw new Error(\"No driving key was provided in the module builder. Did you forget a '.drive()' call?\");\n    }\n    if (typeof this.driverValue === \"undefined\") {\n      throw new Error(\"No driving value was provided in the module builder. Did you forget a '.through()' call?\");\n    }\n    return function (particle) {\n      updateDrivenProperty(particle, _this.driverKey, evaluateModuleDriver(_this.driverValue, calculateModuleFactor(_this.factor, particle), particle), _this.isRelative);\n    };\n  };\n  return ModuleBuilder;\n}();\nexports.ModuleBuilder = ModuleBuilder;\n/**\r\n * Evaluates the module driver using a specified factor.\r\n */\nfunction evaluateModuleDriver(driver, factor, particle) {\n  if (typeof driver === \"object\" && \"evaluate\" in driver) {\n    return driver.evaluate(factor);\n  }\n  if (typeof driver === \"function\") {\n    return driver(factor, particle);\n  }\n  return driver;\n}\n/**\r\n * Calculates a module factor using a specified particle as context.\r\n */\nfunction calculateModuleFactor(factor, particle) {\n  switch (factor) {\n    case \"lifetime\":\n      return particle.initialLifetime - particle.lifetime;\n    case \"relativeLifetime\":\n      return (particle.initialLifetime - particle.lifetime) / particle.initialLifetime;\n    case \"size\":\n      return particle.size;\n    default:\n      throw new Error(\"Invalid driving factor '\" + factor + \"'.\");\n  }\n}\n/**\r\n * Updates a driven property of a particle using the specified value.\r\n *\r\n * @remarks\r\n * If the operation is marked as relative, the function infers the new value\r\n * through the value's type. Note that relative properties must have a\r\n * corresponding \"initial*\" value in the particle's properties.\r\n */\nfunction updateDrivenProperty(particle, key, value, relative) {\n  if (relative === void 0) {\n    relative = false;\n  }\n  if (!relative) {\n    particle[key] = value;\n  } else {\n    var initial = particle[\"initial\" + key[0].toUpperCase() + key.substr(1)];\n    if (typeof initial === \"undefined\") {\n      throw new Error(\"Unable to use relative chaining with key '\" + key + \"'; no initial value exists.\");\n    }\n    if (value instanceof components_1.Vector) {\n      updateDrivenProperty(particle, key, initial.add(value));\n    } else if (typeof value === \"number\") {\n      updateDrivenProperty(particle, key, initial * value);\n    } else {\n      throw new Error(\"Unable to use relative chaining with particle key '\" + key + \"'; no relative operation for '\" + value + \"' could be inferred.\");\n    }\n  }\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","ModuleBuilder","components_1","require","factor","isRelative","prototype","drive","key","driverKey","through","by","driver","driverValue","relative","build","_this","Error","particle","updateDrivenProperty","evaluateModuleDriver","calculateModuleFactor","evaluate","initialLifetime","lifetime","size","initial","toUpperCase","substr","Vector","add"],"sources":["C:/works/react-test/node_modules/party-js/lib/systems/modules.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ModuleBuilder = void 0;\r\nvar components_1 = require(\"../components\");\r\n/**\r\n * Represents a builder for particle modules. Returns an evaluatable module\r\n * function, that can be consumed by emitters.\r\n *\r\n * @remarks\r\n * Not all properties can be driven. TypeScript will validate this at compile time,\r\n * but no internal validation is performed due to performance reasons. Also, note\r\n * that the driving factor is \"lifetime\" by default.\r\n *\r\n * @example\r\n * ```ts\r\n * new ModuleBuilder()\r\n *     .drive(\"size\")\r\n *     .by((t) => t * 2)\r\n *     .through(\"lifetime\")\r\n *     .build();\r\n * ```\r\n */\r\nvar ModuleBuilder = /** @class */ (function () {\r\n    function ModuleBuilder() {\r\n        /**\r\n         * The factor driving the built function.\r\n         *\r\n         * @defaultValue \"lifetime\"\r\n         */\r\n        this.factor = \"lifetime\";\r\n        this.isRelative = false;\r\n    }\r\n    /**\r\n     * Specifies the key in the particle that should be driven.\r\n     *\r\n     * @remarks\r\n     * Note that not all of a particle's properties are drivable through modules. If you\r\n     * need full control of a particle inside of a module, you can use a module function directly.\r\n     *\r\n     * @returns The chained builder instance.\r\n     */\r\n    ModuleBuilder.prototype.drive = function (key) {\r\n        this.driverKey = key;\r\n        return this;\r\n    };\r\n    /**\r\n     * Specifies the factor to drive the evaluated value by. Supports \"lifetime\" and \"size\".\r\n     *\r\n     * @returns The chained builder instance.\r\n     */\r\n    ModuleBuilder.prototype.through = function (factor) {\r\n        this.factor = factor;\r\n        return this;\r\n    };\r\n    /**\r\n     * Specifies the value to drive the module behaviour by. This can be a constant,\r\n     * a spline or an evaluable function. Note that in the last case, the driving\r\n     * factor is passed as a parameter.\r\n     *\r\n     * @returns The chained builder instance.\r\n     */\r\n    ModuleBuilder.prototype.by = function (driver) {\r\n        this.driverValue = driver;\r\n        return this;\r\n    };\r\n    /**\r\n     * Specifies that the module function is supposed to act relative to the\r\n     * properties initial value.\r\n     *\r\n     * @remarks\r\n     * Note that this is only possible if an \"initial*\" property exists on the\r\n     * particle object. The operation applied to the initial and new value\r\n     * is dependant on their type:\r\n     * - `Vector`: Both vectors are added.\r\n     * - `number`: Both numbers are multiplied.\r\n     *\r\n     * For more advanced relative customizations, consider using the particle\r\n     * object in the driver value function instead, like:\r\n     * ```ts\r\n     * .by((t, p) => p.initialSize + t * 2);\r\n     * ```\r\n     */\r\n    ModuleBuilder.prototype.relative = function (isRelative) {\r\n        if (isRelative === void 0) { isRelative = true; }\r\n        this.isRelative = isRelative;\r\n        return this;\r\n    };\r\n    /**\r\n     * Consumes the builder and returns an evaluatable module function.\r\n     *\r\n     * @remarks\r\n     * Note that you need to specify the driving key and value, otherwise an error\r\n     * will be thrown.\r\n     */\r\n    ModuleBuilder.prototype.build = function () {\r\n        var _this = this;\r\n        if (typeof this.driverKey === \"undefined\") {\r\n            throw new Error(\"No driving key was provided in the module builder. Did you forget a '.drive()' call?\");\r\n        }\r\n        if (typeof this.driverValue === \"undefined\") {\r\n            throw new Error(\"No driving value was provided in the module builder. Did you forget a '.through()' call?\");\r\n        }\r\n        return function (particle) {\r\n            updateDrivenProperty(particle, _this.driverKey, evaluateModuleDriver(_this.driverValue, calculateModuleFactor(_this.factor, particle), particle), _this.isRelative);\r\n        };\r\n    };\r\n    return ModuleBuilder;\r\n}());\r\nexports.ModuleBuilder = ModuleBuilder;\r\n/**\r\n * Evaluates the module driver using a specified factor.\r\n */\r\nfunction evaluateModuleDriver(driver, factor, particle) {\r\n    if (typeof driver === \"object\" && \"evaluate\" in driver) {\r\n        return driver.evaluate(factor);\r\n    }\r\n    if (typeof driver === \"function\") {\r\n        return driver(factor, particle);\r\n    }\r\n    return driver;\r\n}\r\n/**\r\n * Calculates a module factor using a specified particle as context.\r\n */\r\nfunction calculateModuleFactor(factor, particle) {\r\n    switch (factor) {\r\n        case \"lifetime\":\r\n            return particle.initialLifetime - particle.lifetime;\r\n        case \"relativeLifetime\":\r\n            return ((particle.initialLifetime - particle.lifetime) /\r\n                particle.initialLifetime);\r\n        case \"size\":\r\n            return particle.size;\r\n        default:\r\n            throw new Error(\"Invalid driving factor '\" + factor + \"'.\");\r\n    }\r\n}\r\n/**\r\n * Updates a driven property of a particle using the specified value.\r\n *\r\n * @remarks\r\n * If the operation is marked as relative, the function infers the new value\r\n * through the value's type. Note that relative properties must have a\r\n * corresponding \"initial*\" value in the particle's properties.\r\n */\r\nfunction updateDrivenProperty(particle, key, value, relative) {\r\n    if (relative === void 0) { relative = false; }\r\n    if (!relative) {\r\n        particle[key] = value;\r\n    }\r\n    else {\r\n        var initial = particle[\"initial\" + key[0].toUpperCase() + key.substr(1)];\r\n        if (typeof initial === \"undefined\") {\r\n            throw new Error(\"Unable to use relative chaining with key '\" + key + \"'; no initial value exists.\");\r\n        }\r\n        if (value instanceof components_1.Vector) {\r\n            updateDrivenProperty(particle, key, initial.add(value));\r\n        }\r\n        else if (typeof value === \"number\") {\r\n            updateDrivenProperty(particle, key, initial * value);\r\n        }\r\n        else {\r\n            throw new Error(\"Unable to use relative chaining with particle key '\" + key + \"'; no relative operation for '\" + value + \"' could be inferred.\");\r\n        }\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}